<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>niconico_dl API documentation</title>
<meta name="description" content="![PyPI](https://img.shields.io/pypi/v/niconico-dl) ![PyPI - Downloads](https://img.shields.io/pypi/dm/niconico_dl)
niconico_dl
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>niconico_dl</code></h1>
</header>
<section id="section-intro">
<p><img alt="PyPI" src="https://img.shields.io/pypi/v/niconico-dl"> <img alt="PyPI - Downloads" src="https://img.shields.io/pypi/dm/niconico_dl"></p>
<h1 id="niconico_dl">niconico_dl</h1>
<p>ニコニコ動画にある動画をダウンロードするためのPython用のライブラリです。
</p>
<p><strong>警告！</strong><br>
このniconico_dlは開発が停止して、アップデートもこれからありません。<br>
代わりに<a href="https://github.com/niconicolibs/niconico.py">こちら</a>を使用してください。</p>
<p>リファレンス：<a href="https://tasuren.github.io/niconico-dl/">https://tasuren.github.io/niconico-dl/</a><br>
GitHub：<a href="https://github.com/tasuren/niconico-dl/">https://github.com/tasuren/niconico-dl/</a></p>
<h2 id="install">Install</h2>
<p><code>pip install <a title="niconico_dl" href="#niconico_dl">niconico_dl</a></code></p>
<h2 id="examples">Examples</h2>
<h3 id="normal">Normal</h3>
<pre><code class="language-python">url = &quot;https://www.nicovideo.jp/watch/sm38533566&quot;

with niconico_dl.NicoNicoVideo(url, log=True) as nico:
    data = nico.get_info()
    nico.download(data[&quot;video&quot;][&quot;title&quot;] + &quot;.mp4&quot;)

print(&quot;Downloaded!&quot;)
</code></pre>
<h3 id="async">Async</h3>
<pre><code class="language-python">async def start_async():
    url = &quot;https://www.nicovideo.jp/watch/sm9664372&quot;
    async with niconico_dl.NicoNicoVideoAsync(url, log=True) as nico:
        data = await nico.get_info()
        await nico.download(data[&quot;video&quot;][&quot;title&quot;] + &quot;.mp4&quot;)
    print(&quot;Downloaded!&quot;)


asyncio.run(start_async())
</code></pre>
<h3 id="command-line">Command Line</h3>
<p>使用方法：<code><a title="niconico_dl" href="#niconico_dl">niconico_dl</a> [URL]</code><br>
ダウンロードした動画は<code>output.mp4</code>という名前で実行したディレクトリに保存されます。</p>
<h2 id="notes">Notes</h2>
<p>もしDiscordのボイスチャットにニコニコ動画を流したい人は<code><a title="niconico_dl.NicoNicoVideoAsync.download" href="#niconico_dl.NicoNicoVideoAsync.download">NicoNicoVideoAsync.download()</a></code>ではなく<code><a title="niconico_dl.NicoNicoVideoAsync.get_download_link" href="#niconico_dl.NicoNicoVideoAsync.get_download_link">NicoNicoVideoAsync.get_download_link()</a></code>を使用して取得したダウンロードリンクで流すことを推奨します。<br>
<code>download</code>は動画をダウンロードするため時間がかかります。
なので<code>get_download_link</code>でダウンロードリンクを取得してそれを使い直接流すのを推奨します。<br>
注意：<code>close</code>をお忘れなく、詳細はリファレンスを見てください。</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ../README.md
&#34;&#34;&#34;

from .async_video_manager import *
from .video_manager import *


__all__ = (&#34;HEADERS&#34;, &#34;NicoNicoAcquisitionFailed&#34;,
           &#34;NicoNicoVideoAsync&#34;, &#34;NicoNicoVideo&#34;)
__author__ = &#34;tasuren&#34;
__version__ = &#34;2.2.8&#34;</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="niconico_dl.async_video_manager" href="async_video_manager.html">niconico_dl.async_video_manager</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="niconico_dl.templates" href="templates.html">niconico_dl.templates</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="niconico_dl.video_manager" href="video_manager.html">niconico_dl.video_manager</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="niconico_dl.NicoNicoAcquisitionFailed"><code class="flex name class">
<span>class <span class="ident">NicoNicoAcquisitionFailed</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画から情報を取得するのに失敗した際に発生するもの。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NicoNicoAcquisitionFailed(Exception):
    &#34;&#34;&#34;ニコニコ動画から情報を取得するのに失敗した際に発生するもの。&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="niconico_dl.NicoNicoVideo"><code class="flex name class">
<span>class <span class="ident">NicoNicoVideo</span></span>
<span>(</span><span>url: str, log: bool = False, headers: Optional[dict] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画の情報や動画を取得するためのクラスです。<br>
このクラスから動画データの取得やダウンロードが行なえます。</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>ニコニコ動画のURLです。</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>ログ出力をするかどうかです。</dd>
<dt><strong><code>headers</code></strong> :&ensp;<code>dict, Optional</code></dt>
<dd>通信時に使用するヘッダーです。<br>
指定されない場合は<code>niconico_dl.HEADERS</code>を使用するので普通は変えなくて大丈夫です。</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>heartbeat_thread</code></strong> :&ensp;<code>threading.Thread</code></dt>
<dd>Heartbeatのスレッドです。<br>
Heartbeatを動かすまでこれはNoneです。</dd>
</dl>
<h2 id="seealso">Seealso</h2>
<p>NicoNicoVideoAsync : このクラスの非同期バージョンです。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NicoNicoVideo:
    &#34;&#34;&#34;ニコニコ動画の情報や動画を取得するためのクラスです。  
    このクラスから動画データの取得やダウンロードが行なえます。

    Parameters
    ----------
    url : str
        ニコニコ動画のURLです。
    log : bool, default False
        ログ出力をするかどうかです。
    headers : dict, Optional
        通信時に使用するヘッダーです。  
        指定されない場合は`niconico_dl.HEADERS`を使用するので普通は変えなくて大丈夫です。

    Attributes
    ----------
    heartbeat_thread : threading.Thread
        Heartbeatのスレッドです。  
        Heartbeatを動かすまでこれはNoneです。

    SeeAlso
    -------
    NicoNicoVideoAsync : このクラスの非同期バージョンです。&#34;&#34;&#34;
    def __init__(
        self, url: str, log: bool = False, headers: Optional[dict] = None
    ):
        self._headers = headers or HEADERS
        self.heartbeat_thread: Thread = None

        if &#34;nico.ms&#34; in url:
            url = url.replace(&#34;nico.ms/&#34;, &#34;www.nicovideo.jp/watch/&#34;)
        
        if &#34;sp&#34; in url:
            url = url.replace(&#34;sp&#34;, &#34;www&#34;)

        self._url, self._log = url, log
        self._data, self._download_link = {}, None
        self._working_heartbeat = False
        self._stop = False

    def print(self, *args, first: str = &#34;&#34;, **kwargs) -&gt; None:
        &#34;&#34;&#34;niconico_dl用に用意したログ出力用の`print`です。&#34;&#34;&#34;
        if self._log:
            print(
                f&#34;{first}[niconico_dl]&#34;,
                *args, **kwargs
            )

    def __enter__(self):
        # `with`構文の最初に呼び出されるもの。
        # Heartbnneatを動かします。
        self.connect()
        return self

    def __exit__(self, exc_type, exc, tb):
        # `with`構文から抜けた際に呼び出されるもの。
        # Heartbeatをストップします。
        self.close()

    def connect(self) -&gt; None:
        &#34;&#34;&#34;ニコニコ動画に接続します。  
        `download`を使用するにはこれを実行してからする必要があります。  
        そしてニコニコ動画との通信が終了したのなら`close`を実行する必要があります。

        Notes
        -----
        これと`close`は以下のように`with`構文で省略が可能です。  
        ```python
        url = &#34;https://www.nicovideo.jp/watch/sm15713037&#34;
        with niconico_dl.NicoNicoVideo(url) as nico:
            nico.download(&#34;video.mp4&#34;)
        ```&#34;&#34;&#34;
        self.heartbeat_thread = Thread(
            target=self._heartbeat,
            name=&#34;niconico_dl.heartbeat&#34;
        )
        self.heartbeat_thread.start()
        self.wait_until_working_heartbeat()

    def close(self, close_loop: bool = True) -&gt; None:
        &#34;&#34;&#34;NicoNicoVideoAsyncを終了します。  
        動画のダウンロードに必要な通信をするHeartbeatを止めます。  
        もし動画のダウンロードが終わったのならこれを実行してください。  
        `with`構文を使用するのならこれを実行する必要はありません。  
        `with`構文の使用例は`connect`の説明にあります。&#34;&#34;&#34;
        self._stop = True
        self.heartbeat_thread.join()

    def get_info(self) -&gt; dict:
        &#34;&#34;&#34;ニコニコ動画のウェブページから動画のデータを取得する関数です。

        Returns
        -------
        data : dict
            取得した動画の情報です。

        Raises
        ------
        NicoNicoAcquisitionFailed
            ニコニコ動画から情報を取得するのに失敗した際に発生します。&#34;&#34;&#34;
        self.print(&#34;Getting video data...&#34;)
        if not self._data:
            # もし動画データを取得していないなら動画URLのHTMLから動画データを取得する。
            # Heartbeatの通信にも必要なものでもあります。
            soup = BeautifulSoup(
                requests.get(self._url, headers=self._headers[2]).text,
                &#34;html.parser&#34;
            )
            data = soup.find(
                &#34;div&#34;, {&#34;id&#34;: &#34;js-initial-watch-data&#34;}
            ).get(&#34;data-api-data&#34;)
            if data:
                self._data = loads(data)
            else:
                raise NicoNicoAcquisitionFailed(&#34;ニコニコ動画から情報を取得するのに失敗しました。&#34;)
        self.print(&#34;Done.&#34;)
        return self._data

    def wait_until_working_heartbeat(self) -&gt; None:
        &#34;&#34;&#34;Heartbeatが動き出すまで待機します。&#34;&#34;&#34;
        while not self._working_heartbeat:
            pass

    def is_working_heartbeat(self) -&gt; bool:
        &#34;&#34;&#34;Heartbeatが動いているかの真偽値を返します。

        Returns
        -------
        is_working : bool
            Heartbeatが動いているかどうかの真偽値です。&#34;&#34;&#34;
        return self._working_heartbeat

    def get_download_link(self) -&gt; str:
        &#34;&#34;&#34;
        ニコニコ動画の動画のダウンロードリンクを取得します。  
        返されるリンクからはmp4の動画をダウンロードできます。

        Returns
        -------
        str : Download link

        Warnings
        --------
        返されるダウンロードリンクはHeartbeatが動いている間でしか使うことができません。  
        ですのでHeartbeatを止める`close`はダウンロードリンクの使用が終わってから実行しましょう。  
        したがって`with`構文を使用して取得したダウンロードリンクはすぐに使えなくなることがあるので注意してください。
        &#34;&#34;&#34;
        if self._download_link is None:
            # Heartbeatが動いていないなら動かす。
            if not self.is_working_heartbeat():
                self.connect()
            # Heartbeatが動画のURLを取得するまで待機する。
            self.wait_until_working_heartbeat()
            self._download_link = self.result_data[&#34;content_uri&#34;]

        return self._download_link

    def download(self, path: str, load_chunk_size: int = 1024) -&gt; None:
        &#34;&#34;&#34;ニコニコ動画の動画をダウンロードします。  
        mp4形式でダウンロードされます。

        Examples
        --------
        ```python
        url = &#34;https://www.nicovideo.jp/watch/sm1097445&#34;
        with NicoNicoVideo(url) as nico:
            data = nico.get_info()
            title = data[&#34;video&#34;][&#34;title&#34;]
            nico.download(title + &#34;.mp4&#34;)
        ```

        Notes
        -----
        もし`with`構文を使用しないでダウンロードする場合は、ダウンロード前に`connect`を、ダウンロード終了後に`close`を実行してください。  
        動画データの通信に必要なHeartbeatが永遠に動き続けることになります。

        Parameters
        ----------
        path : str
            ダウンロードするニコニコ動画の動画の保存先です。
        load_chunk_size : int, default 1024
            一度にどれほどの量をダウンロードするかです。&#34;&#34;&#34;
        self.print(&#34;Now loading...&#34;)
        url = self.get_download_link()

        params = (
            (
                &#34;ht2_nicovideo&#34;,
                self.result_data[&#34;content_auth&#34;][&#34;content_auth_info&#34;][&#34;value&#34;]
            ),
        )
        headers = self._headers[1]
        headers[&#34;Content-Type&#34;] = &#34;video/mp4&#34;

        BASE = &#34;Downloading video... :&#34;
        self.print(BASE, &#34;Now loading...&#34;, first=&#34;\r&#34;, end=&#34;&#34;)

        size = int(
            requests.head(
                url, headers=headers, params=params
            ).headers.get(&#34;content-length&#34;)
        )

        r = requests.get(url, headers=headers, params=params, stream=True)
        r.raise_for_status()
        now_size = 0

        with open(path, &#34;wb&#34;) as f:
            for chunk in r.iter_content(chunk_size=load_chunk_size):
                if chunk:
                    now_size += len(chunk)
                    f.write(chunk)
                    self.print(
                        BASE,
                        f&#34;{int(now_size/size*100)}% ({now_size}/{size})&#34;,
                        first=&#34;\r&#34;, end=&#34;&#34;
                    )

        self.print(&#34;Done.&#34;, first=&#34;\n&#34;)

    def _heartbeat(self, mode = &#34;http_output_download_parameters&#34;) -&gt; None:
        # Heartbeatです。
        self.print(&#34;Starting heartbeat...&#34;)
        if not self._data:
            self.get_info()

        # セッションに必要なデータを`NicoNicoVideoAsync.get_info`で取得したデータから取得します。
        data = _make_sessiondata(
            self._data[&#34;media&#34;][&#34;delivery&#34;][&#34;movie&#34;], mode=mode
        )
        self.print(&#34;Sending Heartbeat Init Data... :&#34;, data)

        # 一番最初のHeartbeatの通信をします。
        r = requests.post(
            URLS[&#34;base_heartbeat&#34;] + &#34;?_format=json&#34;,
            headers=self._headers[1], data=dumps(data)
        )
        self.result_data = r.json()[&#34;data&#34;][&#34;session&#34;]
        session_id = self.result_data[&#34;id&#34;]

        self.print(&#34;Done. session_id. : &#34; + str(session_id))
        self._working_heartbeat = True

        data, first = {&#34;session&#34;: self.result_data}, True
        get_interval = lambda now: now + data[&#34;session&#34;][&#34;keep_method&#34;][&#34;heartbeat&#34;][&#34;lifetime&#34;] / 1000 - 3
        make_url = lambda session_id: f&#34;{URLS[&#39;base_heartbeat&#39;]}/{session_id}?_format=json&amp;_method=PUT&#34;
        after = get_interval(time())

        while not self._stop:
            now = time()
            # ここで定期的にHeartbeatを送ります。
            if now &gt;= after:
                self.print(&#34;Sending heartbeat...&#34;, data)

                if first:
                    # 最初は普通とは違うものを先にリクエストする必要があるのでそれをリクエストする。
                    r = requests.options(make_url(session_id), headers=self._headers[0])
                    r.raise_for_status()
                    first = False

                r = requests.post(
                    make_url(session_id), headers=self._headers[1],
                    data=dumps(data)
                )
                self.result_data = r.json()[&#34;data&#34;][&#34;session&#34;]

                self.print(&#34;Done.&#34;)
                data = {&#34;session&#34;: self.result_data}
                self.print(&#34;Received data&#34;, data)

                after = get_interval(now)
            else:
                sleep(0.05)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="niconico_dl.NicoNicoVideo.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, close_loop: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>NicoNicoVideoAsyncを終了します。<br>
動画のダウンロードに必要な通信をするHeartbeatを止めます。<br>
もし動画のダウンロードが終わったのならこれを実行してください。<br>
<code>with</code>構文を使用するのならこれを実行する必要はありません。<br>
<code>with</code>構文の使用例は<code>connect</code>の説明にあります。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, close_loop: bool = True) -&gt; None:
    &#34;&#34;&#34;NicoNicoVideoAsyncを終了します。  
    動画のダウンロードに必要な通信をするHeartbeatを止めます。  
    もし動画のダウンロードが終わったのならこれを実行してください。  
    `with`構文を使用するのならこれを実行する必要はありません。  
    `with`構文の使用例は`connect`の説明にあります。&#34;&#34;&#34;
    self._stop = True
    self.heartbeat_thread.join()</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideo.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画に接続します。<br>
<code>download</code>を使用するにはこれを実行してからする必要があります。<br>
そしてニコニコ動画との通信が終了したのなら<code>close</code>を実行する必要があります。</p>
<h2 id="notes">Notes</h2>
<p>これと<code>close</code>は以下のように<code>with</code>構文で省略が可能です。
</p>
<pre><code class="language-python">url = &quot;https://www.nicovideo.jp/watch/sm15713037&quot;
with niconico_dl.NicoNicoVideo(url) as nico:
    nico.download(&quot;video.mp4&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self) -&gt; None:
    &#34;&#34;&#34;ニコニコ動画に接続します。  
    `download`を使用するにはこれを実行してからする必要があります。  
    そしてニコニコ動画との通信が終了したのなら`close`を実行する必要があります。

    Notes
    -----
    これと`close`は以下のように`with`構文で省略が可能です。  
    ```python
    url = &#34;https://www.nicovideo.jp/watch/sm15713037&#34;
    with niconico_dl.NicoNicoVideo(url) as nico:
        nico.download(&#34;video.mp4&#34;)
    ```&#34;&#34;&#34;
    self.heartbeat_thread = Thread(
        target=self._heartbeat,
        name=&#34;niconico_dl.heartbeat&#34;
    )
    self.heartbeat_thread.start()
    self.wait_until_working_heartbeat()</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideo.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, path: str, load_chunk_size: int = 1024) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画の動画をダウンロードします。<br>
mp4形式でダウンロードされます。</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">url = &quot;https://www.nicovideo.jp/watch/sm1097445&quot;
with NicoNicoVideo(url) as nico:
    data = nico.get_info()
    title = data[&quot;video&quot;][&quot;title&quot;]
    nico.download(title + &quot;.mp4&quot;)
</code></pre>
<h2 id="notes">Notes</h2>
<p>もし<code>with</code>構文を使用しないでダウンロードする場合は、ダウンロード前に<code>connect</code>を、ダウンロード終了後に<code>close</code>を実行してください。<br>
動画データの通信に必要なHeartbeatが永遠に動き続けることになります。</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>ダウンロードするニコニコ動画の動画の保存先です。</dd>
<dt><strong><code>load_chunk_size</code></strong> :&ensp;<code>int</code>, default <code>1024</code></dt>
<dd>一度にどれほどの量をダウンロードするかです。</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self, path: str, load_chunk_size: int = 1024) -&gt; None:
    &#34;&#34;&#34;ニコニコ動画の動画をダウンロードします。  
    mp4形式でダウンロードされます。

    Examples
    --------
    ```python
    url = &#34;https://www.nicovideo.jp/watch/sm1097445&#34;
    with NicoNicoVideo(url) as nico:
        data = nico.get_info()
        title = data[&#34;video&#34;][&#34;title&#34;]
        nico.download(title + &#34;.mp4&#34;)
    ```

    Notes
    -----
    もし`with`構文を使用しないでダウンロードする場合は、ダウンロード前に`connect`を、ダウンロード終了後に`close`を実行してください。  
    動画データの通信に必要なHeartbeatが永遠に動き続けることになります。

    Parameters
    ----------
    path : str
        ダウンロードするニコニコ動画の動画の保存先です。
    load_chunk_size : int, default 1024
        一度にどれほどの量をダウンロードするかです。&#34;&#34;&#34;
    self.print(&#34;Now loading...&#34;)
    url = self.get_download_link()

    params = (
        (
            &#34;ht2_nicovideo&#34;,
            self.result_data[&#34;content_auth&#34;][&#34;content_auth_info&#34;][&#34;value&#34;]
        ),
    )
    headers = self._headers[1]
    headers[&#34;Content-Type&#34;] = &#34;video/mp4&#34;

    BASE = &#34;Downloading video... :&#34;
    self.print(BASE, &#34;Now loading...&#34;, first=&#34;\r&#34;, end=&#34;&#34;)

    size = int(
        requests.head(
            url, headers=headers, params=params
        ).headers.get(&#34;content-length&#34;)
    )

    r = requests.get(url, headers=headers, params=params, stream=True)
    r.raise_for_status()
    now_size = 0

    with open(path, &#34;wb&#34;) as f:
        for chunk in r.iter_content(chunk_size=load_chunk_size):
            if chunk:
                now_size += len(chunk)
                f.write(chunk)
                self.print(
                    BASE,
                    f&#34;{int(now_size/size*100)}% ({now_size}/{size})&#34;,
                    first=&#34;\r&#34;, end=&#34;&#34;
                )

    self.print(&#34;Done.&#34;, first=&#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideo.get_download_link"><code class="name flex">
<span>def <span class="ident">get_download_link</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画の動画のダウンロードリンクを取得します。<br>
返されるリンクからはmp4の動画をダウンロードできます。</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong> :&ensp;<code>Download link</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="warnings">Warnings</h2>
<p>返されるダウンロードリンクはHeartbeatが動いている間でしか使うことができません。<br>
ですのでHeartbeatを止める<code>close</code>はダウンロードリンクの使用が終わってから実行しましょう。<br>
したがって<code>with</code>構文を使用して取得したダウンロードリンクはすぐに使えなくなることがあるので注意してください。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_download_link(self) -&gt; str:
    &#34;&#34;&#34;
    ニコニコ動画の動画のダウンロードリンクを取得します。  
    返されるリンクからはmp4の動画をダウンロードできます。

    Returns
    -------
    str : Download link

    Warnings
    --------
    返されるダウンロードリンクはHeartbeatが動いている間でしか使うことができません。  
    ですのでHeartbeatを止める`close`はダウンロードリンクの使用が終わってから実行しましょう。  
    したがって`with`構文を使用して取得したダウンロードリンクはすぐに使えなくなることがあるので注意してください。
    &#34;&#34;&#34;
    if self._download_link is None:
        # Heartbeatが動いていないなら動かす。
        if not self.is_working_heartbeat():
            self.connect()
        # Heartbeatが動画のURLを取得するまで待機する。
        self.wait_until_working_heartbeat()
        self._download_link = self.result_data[&#34;content_uri&#34;]

    return self._download_link</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideo.get_info"><code class="name flex">
<span>def <span class="ident">get_info</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画のウェブページから動画のデータを取得する関数です。</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>取得した動画の情報です。</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="niconico_dl.NicoNicoAcquisitionFailed" href="#niconico_dl.NicoNicoAcquisitionFailed">NicoNicoAcquisitionFailed</a></code></dt>
<dd>ニコニコ動画から情報を取得するのに失敗した際に発生します。</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_info(self) -&gt; dict:
    &#34;&#34;&#34;ニコニコ動画のウェブページから動画のデータを取得する関数です。

    Returns
    -------
    data : dict
        取得した動画の情報です。

    Raises
    ------
    NicoNicoAcquisitionFailed
        ニコニコ動画から情報を取得するのに失敗した際に発生します。&#34;&#34;&#34;
    self.print(&#34;Getting video data...&#34;)
    if not self._data:
        # もし動画データを取得していないなら動画URLのHTMLから動画データを取得する。
        # Heartbeatの通信にも必要なものでもあります。
        soup = BeautifulSoup(
            requests.get(self._url, headers=self._headers[2]).text,
            &#34;html.parser&#34;
        )
        data = soup.find(
            &#34;div&#34;, {&#34;id&#34;: &#34;js-initial-watch-data&#34;}
        ).get(&#34;data-api-data&#34;)
        if data:
            self._data = loads(data)
        else:
            raise NicoNicoAcquisitionFailed(&#34;ニコニコ動画から情報を取得するのに失敗しました。&#34;)
    self.print(&#34;Done.&#34;)
    return self._data</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideo.is_working_heartbeat"><code class="name flex">
<span>def <span class="ident">is_working_heartbeat</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Heartbeatが動いているかの真偽値を返します。</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>is_working</code></strong> :&ensp;<code>bool</code></dt>
<dd>Heartbeatが動いているかどうかの真偽値です。</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_working_heartbeat(self) -&gt; bool:
    &#34;&#34;&#34;Heartbeatが動いているかの真偽値を返します。

    Returns
    -------
    is_working : bool
        Heartbeatが動いているかどうかの真偽値です。&#34;&#34;&#34;
    return self._working_heartbeat</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideo.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, *args, first: str = '', **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>niconico_dl用に用意したログ出力用の<code>print</code>です。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, *args, first: str = &#34;&#34;, **kwargs) -&gt; None:
    &#34;&#34;&#34;niconico_dl用に用意したログ出力用の`print`です。&#34;&#34;&#34;
    if self._log:
        print(
            f&#34;{first}[niconico_dl]&#34;,
            *args, **kwargs
        )</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideo.wait_until_working_heartbeat"><code class="name flex">
<span>def <span class="ident">wait_until_working_heartbeat</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Heartbeatが動き出すまで待機します。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_until_working_heartbeat(self) -&gt; None:
    &#34;&#34;&#34;Heartbeatが動き出すまで待機します。&#34;&#34;&#34;
    while not self._working_heartbeat:
        pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="niconico_dl.NicoNicoVideoAsync"><code class="flex name class">
<span>class <span class="ident">NicoNicoVideoAsync</span></span>
<span>(</span><span>url: str, log: bool = False, headers: Optional[dict] = None, loop: Optional[asyncio.events.AbstractEventLoop] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画の情報や動画を取得するためのクラスです。<br>
このクラスから動画データの取得やダウンロードが行なえます。<br>
ですがこれは非同期版です。(通常は<code><a title="niconico_dl.NicoNicoVideo" href="#niconico_dl.NicoNicoVideo">NicoNicoVideo</a></code>です。)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>ニコニコ動画のURLです。</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>ログ出力をするかどうかです。</dd>
<dt><strong><code>headers</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>通信時に使用するヘッダーです。<br>
デフォルトは<code>niconico_dl.HEADERS</code>が使われるので普通は変えなくて大丈夫です。</dd>
<dt><strong><code>loop</code></strong> :&ensp;<code>asyncio.AbstractLoop</code>, optional</dt>
<dd>使用するイベントループです。<br>
指定しない場合は<code>asyncio.get_event_loop</code>によって自動で取得されます。</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>loop</code></strong> :&ensp;<code>asyncio.AbstractEventLoop</code></dt>
<dd>使用しているイベントループです。</dd>
<dt><strong><code>heartbeat_task</code></strong> :&ensp;<code>asyncio.Task</code></dt>
<dd>HeartbeatのTaskです。<br>
Heartbeatを動かすまでこれはNoneです。</dd>
</dl>
<h2 id="seealso">Seealso</h2>
<p>NicoNicoVideo : このクラスの非非同期版です。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NicoNicoVideoAsync:
    &#34;&#34;&#34;ニコニコ動画の情報や動画を取得するためのクラスです。  
    このクラスから動画データの取得やダウンロードが行なえます。  
    ですがこれは非同期版です。(通常は`NicoNicoVideo`です。)

    Parameters
    ----------
    url : str
        ニコニコ動画のURLです。
    log : bool, default False
        ログ出力をするかどうかです。
    headers : dict, optional
        通信時に使用するヘッダーです。  
        デフォルトは`niconico_dl.HEADERS`が使われるので普通は変えなくて大丈夫です。
    loop : asyncio.AbstractLoop, optional
        使用するイベントループです。  
        指定しない場合は`asyncio.get_event_loop`によって自動で取得されます。

    Attributes
    ----------
    loop : asyncio.AbstractEventLoop
        使用しているイベントループです。
    heartbeat_task : asyncio.Task
        HeartbeatのTaskです。  
        Heartbeatを動かすまでこれはNoneです。

    SeeAlso
    -------
    NicoNicoVideo : このクラスの非非同期版です。&#34;&#34;&#34;
    def __init__(
        self, url: str, log: bool = False, headers: Optional[dict] = None,
        loop: Optional[asyncio.AbstractEventLoop] = None
    ):
        self.loop: asyncio.AbstractEventLoop = loop or asyncio.get_event_loop()
        self._headers = headers or HEADERS
        self._download_link = None
        self.heartbeat_task: asyncio.Task = None

        if &#34;nico.ms&#34; in url:
            url = url.replace(&#34;nico.ms/&#34;, &#34;www.nicovideo.jp/watch/&#34;)
        
        if &#34;sp&#34; in url:
            url = url.replace(&#34;sp&#34;, &#34;www&#34;)

        self._url, self._log = url, log
        self._data, self._download_link = {}, None
        self._working_heartbeat = asyncio.Event()
        self._stop = False

    def print(self, *args, first: str = &#34;&#34;, **kwargs) -&gt; None:
        &#34;&#34;&#34;niconico_dl用に用意したログ出力用の`print`です。&#34;&#34;&#34;
        if self._log:
            print(
                f&#34;{first}[niconico_dl_async]&#34;,
                *args, **kwargs
            )

    async def __aenter__(self):
        # `async with`構文の最初に呼び出されるもの。
        # Heartbnneatを動かします。
        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc, tb):
        # `async with`構文から抜けた際に呼び出されるもの。
        # Heartbeatをストップします。
        self.close()

    async def connect(self) -&gt; None:
        &#34;&#34;&#34;ニコニコ動画に接続します。  
        `download`を使用するにはこれを実行してからする必要があります。  
        そしてニコニコ動画との通信が終了したのなら`close`を実行する必要があります。

        Notes
        -----
        これと`close`は以下のように`async with`構文で省略が可能です。  
        ```python
        url = &#34;https://www.nicovideo.jp/watch/sm9664372&#34;
        async with niconico_dl.NicoNicoVideoAsync(url) as nico:
            await nico.download(&#34;video.mp4&#34;)
        ```&#34;&#34;&#34;
        self.heartbeat_task = self.loop.create_task(
            self._heartbeat(), name=&#34;niconico_dl.heartbeat&#34;
        )
        await self.wait_until_working_heartbeat()

    def close(self) -&gt; None:
        &#34;&#34;&#34;NicoNicoVideoAsyncを終了します。  
        動画のダウンロードに必要な通信をするHeartbeatを止めます。  
        もし動画のダウンロードが終わったのならこれを実行してください。  
        `async with`構文を使用するのならこれを実行する必要はありません。  
        `async with`構文の使用例は`connect`にあります。

        Warnings
        --------
        これを使用してもイベントループは閉じません。&#34;&#34;&#34;
        self._stop = True
        if self.heartbeat_task:
            try:
                self.heartbeat_task.cancel()
            except Exception as e:
                if not isinstance(e, asyncio.CancelledError):
                    raise e

    async def get_info(self) -&gt; dict:
        &#34;&#34;&#34;ニコニコ動画のウェブページから動画のデータを取得するコルーチン関数です。

        Returns
        -------
        data : dict
            取得した動画の情報です。

        Raises
        ------
        NicoNicoAcquisitionFailed
            ニコニコ動画から情報を取得するのに失敗した際に発生します。&#34;&#34;&#34;
        self.print(&#34;Getting video data...&#34;)
        if not self._data:
            # もし動画データを取得していないなら動画URLのHTMLから動画データを取得する。
            # Heartbeatの通信にも必要なものでもあります。
            async with ClientSession(raise_for_status=True) as session:
                async with session.get(self._url, headers=self._headers[2]) as r:
                    soup = BeautifulSoup(await r.text(), &#34;html.parser&#34;)
                    data = soup.find(
                        &#34;div&#34;, {&#34;id&#34;: &#34;js-initial-watch-data&#34;}
                    ).get(&#34;data-api-data&#34;)
                    if data:
                        self._data = loads(data)
                    else:
                        raise NicoNicoAcquisitionFailed(
                            &#34;ニコニコ動画から情報を取得するのに失敗しました。&#34;
                        )
        self.print(&#34;Done.&#34;)
        return self._data

    async def wait_until_working_heartbeat(self) -&gt; None:
        &#34;&#34;&#34;Heartbeatが動き出すまで待機します。&#34;&#34;&#34;
        await self._working_heartbeat.wait()

    def is_working_heartbeat(self) -&gt; bool:
        &#34;&#34;&#34;Heartbeatが動いているかの真偽値を返します。

        Returns
        -------
        is_working : bool
            Heartbeatが動いているかどうかの真偽値です。&#34;&#34;&#34;
        return self._working_heartbeat.is_set()

    async def get_download_link(self) -&gt; str:
        &#34;&#34;&#34;
        ニコニコ動画の動画のダウンロードリンクを取得します。  
        返されるリンクからはmp4の動画をダウンロードできます。

        Returns
        -------
        str : Download link

        Warnings
        --------
        返されるダウンロードリンクはHeartbeatが動いている間でしか使うことができません。  
        ですのでHeartbeatを止める`close`はダウンロードリンクの使用が終わってから実行しましょう。  
        したがって`async with`構文を使用して取得したダウンロードリンクはすぐに使えなくなることがあるので注意してください。
        &#34;&#34;&#34;
        if self._download_link is None:
            # Heartbeatが動いていないなら動かす。
            if not self.is_working_heartbeat():
                await self.connect()
            # Heartbeatが動画のURLを取得するまで待機する。
            await self.wait_until_working_heartbeat()
            self._download_link = self.result_data[&#34;content_uri&#34;]

        return self._download_link

    async def download(self, path: str, load_chunk_size: int = 1024) -&gt; None:
        &#34;&#34;&#34;ニコニコ動画の動画をダウンロードします。  
        mp4形式でダウンロードされます。

        Examples
        --------
        ```python
        url = &#34;https://www.nicovideo.jp/watch/sm9720246&#34;
        async with NicoNicoVideoAsync(url) as nico:
            data = await nico.get_info()
            title = data[&#34;video&#34;][&#34;title&#34;]
            await nico.download(title + &#34;.mp4&#34;)
        ```

        Notes
        -----
        もし`async with`構文を使用しないでダウンロードする場合は、ダウンロード前に`connect`を、ダウンロード終了後に`close`を実行してください。  
        動画データの通信に必要なHeartbeatが永遠に動き続けることになります。

        Parameters
        ----------
        path : str
            ダウンロードするニコニコ動画の動画の保存先です。
        load_chunk_size : int, default 1024
            一度にどれほどの量をダウンロードするかです。&#34;&#34;&#34;
        self.print(&#34;Now loading...&#34;)
        url = await self.get_download_link()

        params = (
            (
                &#34;ht2_nicovideo&#34;,
                self.result_data[&#34;content_auth&#34;][&#34;content_auth_info&#34;][&#34;value&#34;]
            ),
        )
        headers = self._headers[1]
        headers[&#34;Content-Type&#34;] = &#34;video/mp4&#34;

        BASE = &#34;Downloading video... :&#34;
        self.print(BASE, &#34;Now loading...&#34;, first=&#34;\r&#34;, end=&#34;&#34;)

        async with ClientSession(raise_for_status=True) as session:
            async with session.get(url, headers=headers, params=params) as r:
                size, now_size = r.content_length, 0

                self.print(BASE, &#34;Making a null file...&#34;, first=&#34;\r&#34;, end=&#34;&#34;)

                async with async_open(path, &#34;wb&#34;) as f:
                    await f.write(b&#34;&#34;)
                async with async_open(path, &#34;ab&#34;) as f:
                    async for chunk in r.content.iter_chunked(load_chunk_size):
                        if chunk:
                            now_size += len(chunk)
                            await f.write(chunk)
                            self.print(
                                BASE,
                                f&#34;{int(now_size/size*100)}% ({now_size}/{size})&#34;,
                                first=&#34;\r&#34;, end=&#34;&#34;
                            )

        self.print(&#34;Done.&#34;)

    async def _heartbeat(self, mode = &#34;http_output_download_parameters&#34;) -&gt; None:
        # Heartbeatです。
        self.print(&#34;Starting heartbeat...&#34;)
        if not self._data:
            await self.get_info()

        # セッションに必要なデータを`NicoNicoVideoAsync.get_info`で取得したデータから取得します。
        data = _make_sessiondata(
            self._data[&#34;media&#34;][&#34;delivery&#34;][&#34;movie&#34;], mode=mode
        )
        self.print(&#34;Sending Heartbeat Init Data... :&#34;, data)

        # 一番最初のHeartbeatの通信をします。
        async with ClientSession(raise_for_status=True) as session:
            async with session.post(
                URLS[&#34;base_heartbeat&#34;] + &#34;?_format=json&#34;,
                headers=self._headers[1], json=data
            ) as r:
                self.result_data = (await r.json(loads=loads))[&#34;data&#34;][&#34;session&#34;]
        session_id = self.result_data[&#34;id&#34;]

        self.print(&#34;Done. session_id. : &#34; + str(session_id))
        self._working_heartbeat.set()

        data, first = {&#34;session&#34;: self.result_data}, True
        get_interval = lambda now: now + data[&#34;session&#34;][&#34;keep_method&#34;][&#34;heartbeat&#34;][&#34;lifetime&#34;] / 1000 - 3
        make_url = lambda session_id: f&#34;{URLS[&#39;base_heartbeat&#39;]}/{session_id}?_format=json&amp;_method=PUT&#34;
        after = get_interval(time())

        while not self._stop:
            now = time()
            # ここで定期的にHeartbeatを送ります。
            if now &gt;= after:
                self.print(&#34;Sending heartbeat...&#34;, data)

                if first:
                    # 最初は普通とは違うやつもリクエストしないといけないのでする。
                    async with ClientSession(raise_for_status=True) as session:
                        async with session.options(
                            make_url(session_id), headers=self._headers[0]
                        ) as r:
                            r.raise_for_status()
                    first = False

                async with ClientSession(raise_for_status=True) as session:
                    async with session.post(
                        make_url(session_id),
                        headers=self._headers[1], json=data
                    ) as r:
                        self.result_data = (await r.json(loads=loads))[&#34;data&#34;][&#34;session&#34;]

                self.print(&#34;Done.&#34;)
                data = {&#34;session&#34;: self.result_data}

                after = get_interval(now)
            else:
                await asyncio.sleep(0.05)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="niconico_dl.NicoNicoVideoAsync.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>NicoNicoVideoAsyncを終了します。<br>
動画のダウンロードに必要な通信をするHeartbeatを止めます。<br>
もし動画のダウンロードが終わったのならこれを実行してください。<br>
<code>async with</code>構文を使用するのならこれを実行する必要はありません。<br>
<code>async with</code>構文の使用例は<code>connect</code>にあります。</p>
<h2 id="warnings">Warnings</h2>
<p>これを使用してもイベントループは閉じません。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;NicoNicoVideoAsyncを終了します。  
    動画のダウンロードに必要な通信をするHeartbeatを止めます。  
    もし動画のダウンロードが終わったのならこれを実行してください。  
    `async with`構文を使用するのならこれを実行する必要はありません。  
    `async with`構文の使用例は`connect`にあります。

    Warnings
    --------
    これを使用してもイベントループは閉じません。&#34;&#34;&#34;
    self._stop = True
    if self.heartbeat_task:
        try:
            self.heartbeat_task.cancel()
        except Exception as e:
            if not isinstance(e, asyncio.CancelledError):
                raise e</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideoAsync.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画に接続します。<br>
<code>download</code>を使用するにはこれを実行してからする必要があります。<br>
そしてニコニコ動画との通信が終了したのなら<code>close</code>を実行する必要があります。</p>
<h2 id="notes">Notes</h2>
<p>これと<code>close</code>は以下のように<code>async with</code>構文で省略が可能です。
</p>
<pre><code class="language-python">url = &quot;https://www.nicovideo.jp/watch/sm9664372&quot;
async with niconico_dl.NicoNicoVideoAsync(url) as nico:
    await nico.download(&quot;video.mp4&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self) -&gt; None:
    &#34;&#34;&#34;ニコニコ動画に接続します。  
    `download`を使用するにはこれを実行してからする必要があります。  
    そしてニコニコ動画との通信が終了したのなら`close`を実行する必要があります。

    Notes
    -----
    これと`close`は以下のように`async with`構文で省略が可能です。  
    ```python
    url = &#34;https://www.nicovideo.jp/watch/sm9664372&#34;
    async with niconico_dl.NicoNicoVideoAsync(url) as nico:
        await nico.download(&#34;video.mp4&#34;)
    ```&#34;&#34;&#34;
    self.heartbeat_task = self.loop.create_task(
        self._heartbeat(), name=&#34;niconico_dl.heartbeat&#34;
    )
    await self.wait_until_working_heartbeat()</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideoAsync.download"><code class="name flex">
<span>async def <span class="ident">download</span></span>(<span>self, path: str, load_chunk_size: int = 1024) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画の動画をダウンロードします。<br>
mp4形式でダウンロードされます。</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">url = &quot;https://www.nicovideo.jp/watch/sm9720246&quot;
async with NicoNicoVideoAsync(url) as nico:
    data = await nico.get_info()
    title = data[&quot;video&quot;][&quot;title&quot;]
    await nico.download(title + &quot;.mp4&quot;)
</code></pre>
<h2 id="notes">Notes</h2>
<p>もし<code>async with</code>構文を使用しないでダウンロードする場合は、ダウンロード前に<code>connect</code>を、ダウンロード終了後に<code>close</code>を実行してください。<br>
動画データの通信に必要なHeartbeatが永遠に動き続けることになります。</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>ダウンロードするニコニコ動画の動画の保存先です。</dd>
<dt><strong><code>load_chunk_size</code></strong> :&ensp;<code>int</code>, default <code>1024</code></dt>
<dd>一度にどれほどの量をダウンロードするかです。</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def download(self, path: str, load_chunk_size: int = 1024) -&gt; None:
    &#34;&#34;&#34;ニコニコ動画の動画をダウンロードします。  
    mp4形式でダウンロードされます。

    Examples
    --------
    ```python
    url = &#34;https://www.nicovideo.jp/watch/sm9720246&#34;
    async with NicoNicoVideoAsync(url) as nico:
        data = await nico.get_info()
        title = data[&#34;video&#34;][&#34;title&#34;]
        await nico.download(title + &#34;.mp4&#34;)
    ```

    Notes
    -----
    もし`async with`構文を使用しないでダウンロードする場合は、ダウンロード前に`connect`を、ダウンロード終了後に`close`を実行してください。  
    動画データの通信に必要なHeartbeatが永遠に動き続けることになります。

    Parameters
    ----------
    path : str
        ダウンロードするニコニコ動画の動画の保存先です。
    load_chunk_size : int, default 1024
        一度にどれほどの量をダウンロードするかです。&#34;&#34;&#34;
    self.print(&#34;Now loading...&#34;)
    url = await self.get_download_link()

    params = (
        (
            &#34;ht2_nicovideo&#34;,
            self.result_data[&#34;content_auth&#34;][&#34;content_auth_info&#34;][&#34;value&#34;]
        ),
    )
    headers = self._headers[1]
    headers[&#34;Content-Type&#34;] = &#34;video/mp4&#34;

    BASE = &#34;Downloading video... :&#34;
    self.print(BASE, &#34;Now loading...&#34;, first=&#34;\r&#34;, end=&#34;&#34;)

    async with ClientSession(raise_for_status=True) as session:
        async with session.get(url, headers=headers, params=params) as r:
            size, now_size = r.content_length, 0

            self.print(BASE, &#34;Making a null file...&#34;, first=&#34;\r&#34;, end=&#34;&#34;)

            async with async_open(path, &#34;wb&#34;) as f:
                await f.write(b&#34;&#34;)
            async with async_open(path, &#34;ab&#34;) as f:
                async for chunk in r.content.iter_chunked(load_chunk_size):
                    if chunk:
                        now_size += len(chunk)
                        await f.write(chunk)
                        self.print(
                            BASE,
                            f&#34;{int(now_size/size*100)}% ({now_size}/{size})&#34;,
                            first=&#34;\r&#34;, end=&#34;&#34;
                        )

    self.print(&#34;Done.&#34;)</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideoAsync.get_download_link"><code class="name flex">
<span>async def <span class="ident">get_download_link</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画の動画のダウンロードリンクを取得します。<br>
返されるリンクからはmp4の動画をダウンロードできます。</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong> :&ensp;<code>Download link</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="warnings">Warnings</h2>
<p>返されるダウンロードリンクはHeartbeatが動いている間でしか使うことができません。<br>
ですのでHeartbeatを止める<code>close</code>はダウンロードリンクの使用が終わってから実行しましょう。<br>
したがって<code>async with</code>構文を使用して取得したダウンロードリンクはすぐに使えなくなることがあるので注意してください。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_download_link(self) -&gt; str:
    &#34;&#34;&#34;
    ニコニコ動画の動画のダウンロードリンクを取得します。  
    返されるリンクからはmp4の動画をダウンロードできます。

    Returns
    -------
    str : Download link

    Warnings
    --------
    返されるダウンロードリンクはHeartbeatが動いている間でしか使うことができません。  
    ですのでHeartbeatを止める`close`はダウンロードリンクの使用が終わってから実行しましょう。  
    したがって`async with`構文を使用して取得したダウンロードリンクはすぐに使えなくなることがあるので注意してください。
    &#34;&#34;&#34;
    if self._download_link is None:
        # Heartbeatが動いていないなら動かす。
        if not self.is_working_heartbeat():
            await self.connect()
        # Heartbeatが動画のURLを取得するまで待機する。
        await self.wait_until_working_heartbeat()
        self._download_link = self.result_data[&#34;content_uri&#34;]

    return self._download_link</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideoAsync.get_info"><code class="name flex">
<span>async def <span class="ident">get_info</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画のウェブページから動画のデータを取得するコルーチン関数です。</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>取得した動画の情報です。</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="niconico_dl.NicoNicoAcquisitionFailed" href="#niconico_dl.NicoNicoAcquisitionFailed">NicoNicoAcquisitionFailed</a></code></dt>
<dd>ニコニコ動画から情報を取得するのに失敗した際に発生します。</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_info(self) -&gt; dict:
    &#34;&#34;&#34;ニコニコ動画のウェブページから動画のデータを取得するコルーチン関数です。

    Returns
    -------
    data : dict
        取得した動画の情報です。

    Raises
    ------
    NicoNicoAcquisitionFailed
        ニコニコ動画から情報を取得するのに失敗した際に発生します。&#34;&#34;&#34;
    self.print(&#34;Getting video data...&#34;)
    if not self._data:
        # もし動画データを取得していないなら動画URLのHTMLから動画データを取得する。
        # Heartbeatの通信にも必要なものでもあります。
        async with ClientSession(raise_for_status=True) as session:
            async with session.get(self._url, headers=self._headers[2]) as r:
                soup = BeautifulSoup(await r.text(), &#34;html.parser&#34;)
                data = soup.find(
                    &#34;div&#34;, {&#34;id&#34;: &#34;js-initial-watch-data&#34;}
                ).get(&#34;data-api-data&#34;)
                if data:
                    self._data = loads(data)
                else:
                    raise NicoNicoAcquisitionFailed(
                        &#34;ニコニコ動画から情報を取得するのに失敗しました。&#34;
                    )
    self.print(&#34;Done.&#34;)
    return self._data</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideoAsync.is_working_heartbeat"><code class="name flex">
<span>def <span class="ident">is_working_heartbeat</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Heartbeatが動いているかの真偽値を返します。</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>is_working</code></strong> :&ensp;<code>bool</code></dt>
<dd>Heartbeatが動いているかどうかの真偽値です。</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_working_heartbeat(self) -&gt; bool:
    &#34;&#34;&#34;Heartbeatが動いているかの真偽値を返します。

    Returns
    -------
    is_working : bool
        Heartbeatが動いているかどうかの真偽値です。&#34;&#34;&#34;
    return self._working_heartbeat.is_set()</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideoAsync.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, *args, first: str = '', **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>niconico_dl用に用意したログ出力用の<code>print</code>です。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, *args, first: str = &#34;&#34;, **kwargs) -&gt; None:
    &#34;&#34;&#34;niconico_dl用に用意したログ出力用の`print`です。&#34;&#34;&#34;
    if self._log:
        print(
            f&#34;{first}[niconico_dl_async]&#34;,
            *args, **kwargs
        )</code></pre>
</details>
</dd>
<dt id="niconico_dl.NicoNicoVideoAsync.wait_until_working_heartbeat"><code class="name flex">
<span>async def <span class="ident">wait_until_working_heartbeat</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Heartbeatが動き出すまで待機します。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_until_working_heartbeat(self) -&gt; None:
    &#34;&#34;&#34;Heartbeatが動き出すまで待機します。&#34;&#34;&#34;
    await self._working_heartbeat.wait()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#niconico_dl">niconico_dl</a><ul>
<li><a href="#install">Install</a></li>
<li><a href="#examples">Examples</a><ul>
<li><a href="#normal">Normal</a></li>
<li><a href="#async">Async</a></li>
<li><a href="#command-line">Command Line</a></li>
</ul>
</li>
<li><a href="#notes">Notes</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="niconico_dl.async_video_manager" href="async_video_manager.html">niconico_dl.async_video_manager</a></code></li>
<li><code><a title="niconico_dl.templates" href="templates.html">niconico_dl.templates</a></code></li>
<li><code><a title="niconico_dl.video_manager" href="video_manager.html">niconico_dl.video_manager</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="niconico_dl.NicoNicoAcquisitionFailed" href="#niconico_dl.NicoNicoAcquisitionFailed">NicoNicoAcquisitionFailed</a></code></h4>
</li>
<li>
<h4><code><a title="niconico_dl.NicoNicoVideo" href="#niconico_dl.NicoNicoVideo">NicoNicoVideo</a></code></h4>
<ul class="">
<li><code><a title="niconico_dl.NicoNicoVideo.close" href="#niconico_dl.NicoNicoVideo.close">close</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideo.connect" href="#niconico_dl.NicoNicoVideo.connect">connect</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideo.download" href="#niconico_dl.NicoNicoVideo.download">download</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideo.get_download_link" href="#niconico_dl.NicoNicoVideo.get_download_link">get_download_link</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideo.get_info" href="#niconico_dl.NicoNicoVideo.get_info">get_info</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideo.is_working_heartbeat" href="#niconico_dl.NicoNicoVideo.is_working_heartbeat">is_working_heartbeat</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideo.print" href="#niconico_dl.NicoNicoVideo.print">print</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideo.wait_until_working_heartbeat" href="#niconico_dl.NicoNicoVideo.wait_until_working_heartbeat">wait_until_working_heartbeat</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="niconico_dl.NicoNicoVideoAsync" href="#niconico_dl.NicoNicoVideoAsync">NicoNicoVideoAsync</a></code></h4>
<ul class="">
<li><code><a title="niconico_dl.NicoNicoVideoAsync.close" href="#niconico_dl.NicoNicoVideoAsync.close">close</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideoAsync.connect" href="#niconico_dl.NicoNicoVideoAsync.connect">connect</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideoAsync.download" href="#niconico_dl.NicoNicoVideoAsync.download">download</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideoAsync.get_download_link" href="#niconico_dl.NicoNicoVideoAsync.get_download_link">get_download_link</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideoAsync.get_info" href="#niconico_dl.NicoNicoVideoAsync.get_info">get_info</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideoAsync.is_working_heartbeat" href="#niconico_dl.NicoNicoVideoAsync.is_working_heartbeat">is_working_heartbeat</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideoAsync.print" href="#niconico_dl.NicoNicoVideoAsync.print">print</a></code></li>
<li><code><a title="niconico_dl.NicoNicoVideoAsync.wait_until_working_heartbeat" href="#niconico_dl.NicoNicoVideoAsync.wait_until_working_heartbeat">wait_until_working_heartbeat</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
