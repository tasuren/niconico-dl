<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>niconico_dl.async_video_manager API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>niconico_dl.async_video_manager</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># niconico_dl - Async Video Manager by tasuren

from typing import Optional

from aiofiles import open as async_open
from aiohttp import ClientSession
from json import loads, dumps
from bs4 import BeautifulSoup
from time import time
import asyncio

from .templates import (
    _make_sessiondata, HEADERS, URLS, NicoNicoAcquisitionFailed
)


class NicoNicoVideoAsync:
    &#34;&#34;&#34;ニコニコ動画の情報や動画を取得するためのクラスです。  
    このクラスから動画データの取得やダウンロードが行なえます。  
    ですがこれは非同期版です。(通常は`NicoNicoVideo`です。)

    Parameters
    ----------
    url : str
        ニコニコ動画のURLです。
    log : bool, default False
        ログ出力をするかどうかです。
    headers : dict, optional
        通信時に使用するヘッダーです。  
        デフォルトは`niconico_dl.HEADERS`が使われるので普通は変えなくて大丈夫です。
    loop : asyncio.AbstractLoop, optional
        使用するイベントループです。  
        指定しない場合は`asyncio.get_event_loop`によって自動で取得されます。

    Attributes
    ----------
    loop : asyncio.AbstractEventLoop
        使用しているイベントループです。
    heartbeat_task : asyncio.Task
        HeartbeatのTaskです。  
        Heartbeatを動かすまでこれはNoneです。

    SeeAlso
    -------
    NicoNicoVideo : このクラスの非非同期版です。&#34;&#34;&#34;
    def __init__(
        self, url: str, log: bool = False, headers: Optional[dict] = None,
        loop: Optional[asyncio.AbstractEventLoop] = None
    ):
        self.loop: asyncio.AbstractEventLoop = loop or asyncio.get_event_loop()
        self._headers = headers or HEADERS
        self._download_link = None
        self.heartbeat_task: asyncio.Task = None

        if &#34;nico.ms&#34; in url:
            url = url.replace(&#34;nico.ms/&#34;, &#34;www.nicovideo.jp/watch/&#34;)

        self._url, self._log = url, log
        self._data, self._download_link = {}, None
        self._session = ClientSession(raise_for_status=True)
        self._working_heartbeat = asyncio.Event()
        self._stop = False

    def print(self, *args, first: str = &#34;&#34;, **kwargs) -&gt; None:
        &#34;&#34;&#34;niconico_dl用に用意したログ出力用の`print`です。&#34;&#34;&#34;
        if self._log:
            print(
                f&#34;{first}[niconico_dl_async]&#34;,
                *args, **kwargs
            )

    async def __aenter__(self):
        # `async with`構文の最初に呼び出されるもの。
        # Heartbnneatを動かします。
        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc, tb):
        # `async with`構文から抜けた際に呼び出されるもの。
        # Heartbeatをストップします。
        self.close()

    async def connect(self) -&gt; None:
        &#34;&#34;&#34;ニコニコ動画に接続します。  
        `download`を使用するにはこれを実行してからする必要があります。  
        そしてニコニコ動画との通信が終了したのなら`close`を実行する必要があります。

        Notes
        -----
        これと`close`は以下のように`async with`構文で省略が可能です。  
        ```python
        url = &#34;https://www.nicovideo.jp/watch/sm9664372&#34;
        async with niconico_dl.NicoNicoVideoAsync(url) as nico:
            await nico.download(&#34;video.mp4&#34;)
        ```&#34;&#34;&#34;
        self.heartbeat_task = self.loop.create_task(
            self._heartbeat(), name=&#34;niconico_dl.heartbeat&#34;
        )
        await self.wait_until_working_heartbeat()

    def close(self) -&gt; None:
        &#34;&#34;&#34;NicoNicoVideoAsyncを終了します。  
        動画のダウンロードに必要な通信をするHeartbeatを止めます。  
        もし動画のダウンロードが終わったのならこれを実行してください。  
        `async with`構文を使用するのならこれを実行する必要はありません。  
        `async with`構文の使用例は`connect`にあります。

        Warnings
        --------
        これを使用してもイベントループは閉じません。&#34;&#34;&#34;
        self._stop = True
        if self.heartbeat_task:
            try:
                self.heartbeat_task.cancel()
            except Exception as e:
                if not isinstance(e, asyncio.CancelledError):
                    raise e
        if self.loop.is_closed():
            self._session.detach()
        else:
            self.loop.create_task(self._session.close())

    async def get_info(self) -&gt; dict:
        &#34;&#34;&#34;ニコニコ動画のウェブページから動画のデータを取得するコルーチン関数です。

        Returns
        -------
        data : dict
            取得した動画の情報です。

        Raises
        ------
        NicoNicoAcquisitionFailed
            ニコニコ動画から情報を取得するのに失敗した際に発生します。&#34;&#34;&#34;
        self.print(&#34;Getting video data...&#34;)
        if not self._data:
            # もし動画データを取得していないなら動画URLのHTMLから動画データを取得する。
            # Heartbeatの通信にも必要なものでもあります。
            async with self._session.get(self._url, headers=self._headers[2]) as r:
                soup = BeautifulSoup(await r.text(), &#34;html.parser&#34;)
                data = soup.find(&#34;div&#34;, {&#34;id&#34;: &#34;js-initial-watch-data&#34;}).get(&#34;data-api-data&#34;)
                if data:
                    self._data = loads(data)
                else:
                    raise NicoNicoAcquisitionFailed(&#34;ニコニコ動画から情報を取得するのに失敗しました。&#34;)
        self.print(&#34;Done.&#34;)
        return self._data

    async def wait_until_working_heartbeat(self) -&gt; None:
        &#34;&#34;&#34;Heartbeatが動き出すまで待機します。&#34;&#34;&#34;
        await self._working_heartbeat.wait()

    def is_working_heartbeat(self) -&gt; bool:
        &#34;&#34;&#34;Heartbeatが動いているかの真偽値を返します。

        Returns
        -------
        is_working : bool
            Heartbeatが動いているかどうかの真偽値です。&#34;&#34;&#34;
        return self._working_heartbeat.is_set()

    async def get_download_link(self) -&gt; str:
        &#34;&#34;&#34;
        ニコニコ動画の動画のダウンロードリンクを取得します。  
        返されるリンクからはmp4の動画をダウンロードできます。

        Returns
        -------
        str : Download link

        Warnings
        --------
        返されるダウンロードリンクはHeartbeatが動いている間でしか使うことができません。  
        ですのでHeartbeatを止める`close`はダウンロードリンクの使用が終わってから実行しましょう。  
        したがって`async with`構文を使用して取得したダウンロードリンクはすぐに使えなくなることがあるので注意してください。
        &#34;&#34;&#34;
        if self._download_link is None:
            # Heartbeatが動いていないなら動かす。
            if not self.is_working_heartbeat():
                await self.connect()
            # Heartbeatが動画のURLを取得するまで待機する。
            await self.wait_until_working_heartbeat()
            self._download_link = self.result_data[&#34;content_uri&#34;]

        return self._download_link

    async def download(self, path: str, load_chunk_size: int = 1024) -&gt; None:
        &#34;&#34;&#34;ニコニコ動画の動画をダウンロードします。  
        mp4形式でダウンロードされます。

        Examples
        --------
        ```python
        url = &#34;https://www.nicovideo.jp/watch/sm9720246&#34;
        async with NicoNicoVideoAsync(url) as nico:
            data = await nico.get_info()
            title = data[&#34;video&#34;][&#34;title&#34;]
            await nico.download(title + &#34;.mp4&#34;)
        ```

        Notes
        -----
        もし`async with`構文を使用しないでダウンロードする場合は、ダウンロード前に`connect`を、ダウンロード終了後に`close`を実行してください。  
        動画データの通信に必要なHeartbeatが永遠に動き続けることになります。

        Parameters
        ----------
        path : str
            ダウンロードするニコニコ動画の動画の保存先です。
        load_chunk_size : int, default 1024
            一度にどれほどの量をダウンロードするかです。&#34;&#34;&#34;
        self.print(&#34;Now loading...&#34;)
        url = await self.get_download_link()

        params = (
            (
                &#34;ht2_nicovideo&#34;,
                self.result_data[&#34;content_auth&#34;][&#34;content_auth_info&#34;][&#34;value&#34;]
            ),
        )
        headers = self._headers[1]
        headers[&#34;Content-Type&#34;] = &#34;video/mp4&#34;

        BASE = &#34;Downloading video... :&#34;
        self.print(BASE, &#34;Now loading...&#34;, first=&#34;\r&#34;, end=&#34;&#34;)

        async with self._session.get(url, headers=headers, params=params) as r:
            size, now_size = r.content_length, 0

            self.print(BASE, &#34;Making a null file...&#34;, first=&#34;\r&#34;, end=&#34;&#34;)

            async with async_open(path, &#34;wb&#34;) as f:
                await f.write(b&#34;&#34;)
            async with async_open(path, &#34;ab&#34;) as f:
                async for chunk in r.content.iter_chunked(load_chunk_size):
                    if chunk:
                        now_size += len(chunk)
                        await f.write(chunk)
                        self.print(
                            BASE,
                            f&#34;{int(now_size/size*100)}% ({now_size}/{size})&#34;,
                            first=&#34;\r&#34;, end=&#34;&#34;
                        )

        self.print(&#34;Done.&#34;)

    async def _heartbeat(self, mode = &#34;http_output_download_parameters&#34;) -&gt; None:
        # Heartbeatです。
        self.print(&#34;Starting heartbeat...&#34;)
        if not self._data:
            await self.get_info()

        # セッションに必要なデータを`NicoNicoVideoAsync.get_info`で取得したデータから取得します。
        data = _make_sessiondata(
            self._data[&#34;media&#34;][&#34;delivery&#34;][&#34;movie&#34;], mode=mode
        )
        self.print(&#34;Sending Heartbeat Init Data... :&#34;, data)

        # 一番最初のHeartbeatの通信をします。
        async with self._session.post(
            URLS[&#34;base_heartbeat&#34;] + &#34;?_format=json&#34;,
            headers=self._headers[1], json=data
        ) as r:
            self.result_data = (await r.json(loads=loads))[&#34;data&#34;][&#34;session&#34;]
        session_id = self.result_data[&#34;id&#34;]

        self.print(&#34;Done. session_id. : &#34; + str(session_id))
        self._working_heartbeat.set()

        data, first = {&#34;session&#34;: self.result_data}, True
        get_interval = lambda now: now + data[&#34;session&#34;][&#34;keep_method&#34;][&#34;heartbeat&#34;][&#34;lifetime&#34;] / 1000 - 3
        make_url = lambda session_id: f&#34;{URLS[&#39;base_heartbeat&#39;]}/{session_id}?_format=json&amp;_method=PUT&#34;
        after = get_interval(time())

        while not self._stop:
            now = time()
            # ここで定期的にHeartbeatを送ります。
            if now &gt;= after:
                self.print(&#34;Sending heartbeat...&#34;, data)

                if first:
                    # 最初は普通とは違うやつもリクエストしないといけないのでする。
                    async with self._session.options(
                        make_url(session_id), headers=self._headers[0]
                    ) as r:
                        r.raise_for_status()
                    first = False

                async with self._session.post(
                    make_url(session_id),
                    headers=self._headers[1], json=data
                ) as r:
                    self.result_data = (await r.json(loads=loads))[&#34;data&#34;][&#34;session&#34;]

                self.print(&#34;Done.&#34;)
                data = {&#34;session&#34;: self.result_data}

                after = get_interval(now)
            else:
                await asyncio.sleep(0.05)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="niconico_dl.async_video_manager.NicoNicoVideoAsync"><code class="flex name class">
<span>class <span class="ident">NicoNicoVideoAsync</span></span>
<span>(</span><span>url: str, log: bool = False, headers: Optional[dict] = None, loop: Optional[asyncio.events.AbstractEventLoop] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画の情報や動画を取得するためのクラスです。<br>
このクラスから動画データの取得やダウンロードが行なえます。<br>
ですがこれは非同期版です。(通常は<code>NicoNicoVideo</code>です。)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>ニコニコ動画のURLです。</dd>
<dt><strong><code>log</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>ログ出力をするかどうかです。</dd>
<dt><strong><code>headers</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>通信時に使用するヘッダーです。<br>
デフォルトは<code>niconico_dl.HEADERS</code>が使われるので普通は変えなくて大丈夫です。</dd>
<dt><strong><code>loop</code></strong> :&ensp;<code>asyncio.AbstractLoop</code>, optional</dt>
<dd>使用するイベントループです。<br>
指定しない場合は<code>asyncio.get_event_loop</code>によって自動で取得されます。</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>loop</code></strong> :&ensp;<code>asyncio.AbstractEventLoop</code></dt>
<dd>使用しているイベントループです。</dd>
<dt><strong><code>heartbeat_task</code></strong> :&ensp;<code>asyncio.Task</code></dt>
<dd>HeartbeatのTaskです。<br>
Heartbeatを動かすまでこれはNoneです。</dd>
</dl>
<h2 id="seealso">Seealso</h2>
<p>NicoNicoVideo : このクラスの非非同期版です。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NicoNicoVideoAsync:
    &#34;&#34;&#34;ニコニコ動画の情報や動画を取得するためのクラスです。  
    このクラスから動画データの取得やダウンロードが行なえます。  
    ですがこれは非同期版です。(通常は`NicoNicoVideo`です。)

    Parameters
    ----------
    url : str
        ニコニコ動画のURLです。
    log : bool, default False
        ログ出力をするかどうかです。
    headers : dict, optional
        通信時に使用するヘッダーです。  
        デフォルトは`niconico_dl.HEADERS`が使われるので普通は変えなくて大丈夫です。
    loop : asyncio.AbstractLoop, optional
        使用するイベントループです。  
        指定しない場合は`asyncio.get_event_loop`によって自動で取得されます。

    Attributes
    ----------
    loop : asyncio.AbstractEventLoop
        使用しているイベントループです。
    heartbeat_task : asyncio.Task
        HeartbeatのTaskです。  
        Heartbeatを動かすまでこれはNoneです。

    SeeAlso
    -------
    NicoNicoVideo : このクラスの非非同期版です。&#34;&#34;&#34;
    def __init__(
        self, url: str, log: bool = False, headers: Optional[dict] = None,
        loop: Optional[asyncio.AbstractEventLoop] = None
    ):
        self.loop: asyncio.AbstractEventLoop = loop or asyncio.get_event_loop()
        self._headers = headers or HEADERS
        self._download_link = None
        self.heartbeat_task: asyncio.Task = None

        if &#34;nico.ms&#34; in url:
            url = url.replace(&#34;nico.ms/&#34;, &#34;www.nicovideo.jp/watch/&#34;)

        self._url, self._log = url, log
        self._data, self._download_link = {}, None
        self._session = ClientSession(raise_for_status=True)
        self._working_heartbeat = asyncio.Event()
        self._stop = False

    def print(self, *args, first: str = &#34;&#34;, **kwargs) -&gt; None:
        &#34;&#34;&#34;niconico_dl用に用意したログ出力用の`print`です。&#34;&#34;&#34;
        if self._log:
            print(
                f&#34;{first}[niconico_dl_async]&#34;,
                *args, **kwargs
            )

    async def __aenter__(self):
        # `async with`構文の最初に呼び出されるもの。
        # Heartbnneatを動かします。
        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc, tb):
        # `async with`構文から抜けた際に呼び出されるもの。
        # Heartbeatをストップします。
        self.close()

    async def connect(self) -&gt; None:
        &#34;&#34;&#34;ニコニコ動画に接続します。  
        `download`を使用するにはこれを実行してからする必要があります。  
        そしてニコニコ動画との通信が終了したのなら`close`を実行する必要があります。

        Notes
        -----
        これと`close`は以下のように`async with`構文で省略が可能です。  
        ```python
        url = &#34;https://www.nicovideo.jp/watch/sm9664372&#34;
        async with niconico_dl.NicoNicoVideoAsync(url) as nico:
            await nico.download(&#34;video.mp4&#34;)
        ```&#34;&#34;&#34;
        self.heartbeat_task = self.loop.create_task(
            self._heartbeat(), name=&#34;niconico_dl.heartbeat&#34;
        )
        await self.wait_until_working_heartbeat()

    def close(self) -&gt; None:
        &#34;&#34;&#34;NicoNicoVideoAsyncを終了します。  
        動画のダウンロードに必要な通信をするHeartbeatを止めます。  
        もし動画のダウンロードが終わったのならこれを実行してください。  
        `async with`構文を使用するのならこれを実行する必要はありません。  
        `async with`構文の使用例は`connect`にあります。

        Warnings
        --------
        これを使用してもイベントループは閉じません。&#34;&#34;&#34;
        self._stop = True
        if self.heartbeat_task:
            try:
                self.heartbeat_task.cancel()
            except Exception as e:
                if not isinstance(e, asyncio.CancelledError):
                    raise e
        if self.loop.is_closed():
            self._session.detach()
        else:
            self.loop.create_task(self._session.close())

    async def get_info(self) -&gt; dict:
        &#34;&#34;&#34;ニコニコ動画のウェブページから動画のデータを取得するコルーチン関数です。

        Returns
        -------
        data : dict
            取得した動画の情報です。

        Raises
        ------
        NicoNicoAcquisitionFailed
            ニコニコ動画から情報を取得するのに失敗した際に発生します。&#34;&#34;&#34;
        self.print(&#34;Getting video data...&#34;)
        if not self._data:
            # もし動画データを取得していないなら動画URLのHTMLから動画データを取得する。
            # Heartbeatの通信にも必要なものでもあります。
            async with self._session.get(self._url, headers=self._headers[2]) as r:
                soup = BeautifulSoup(await r.text(), &#34;html.parser&#34;)
                data = soup.find(&#34;div&#34;, {&#34;id&#34;: &#34;js-initial-watch-data&#34;}).get(&#34;data-api-data&#34;)
                if data:
                    self._data = loads(data)
                else:
                    raise NicoNicoAcquisitionFailed(&#34;ニコニコ動画から情報を取得するのに失敗しました。&#34;)
        self.print(&#34;Done.&#34;)
        return self._data

    async def wait_until_working_heartbeat(self) -&gt; None:
        &#34;&#34;&#34;Heartbeatが動き出すまで待機します。&#34;&#34;&#34;
        await self._working_heartbeat.wait()

    def is_working_heartbeat(self) -&gt; bool:
        &#34;&#34;&#34;Heartbeatが動いているかの真偽値を返します。

        Returns
        -------
        is_working : bool
            Heartbeatが動いているかどうかの真偽値です。&#34;&#34;&#34;
        return self._working_heartbeat.is_set()

    async def get_download_link(self) -&gt; str:
        &#34;&#34;&#34;
        ニコニコ動画の動画のダウンロードリンクを取得します。  
        返されるリンクからはmp4の動画をダウンロードできます。

        Returns
        -------
        str : Download link

        Warnings
        --------
        返されるダウンロードリンクはHeartbeatが動いている間でしか使うことができません。  
        ですのでHeartbeatを止める`close`はダウンロードリンクの使用が終わってから実行しましょう。  
        したがって`async with`構文を使用して取得したダウンロードリンクはすぐに使えなくなることがあるので注意してください。
        &#34;&#34;&#34;
        if self._download_link is None:
            # Heartbeatが動いていないなら動かす。
            if not self.is_working_heartbeat():
                await self.connect()
            # Heartbeatが動画のURLを取得するまで待機する。
            await self.wait_until_working_heartbeat()
            self._download_link = self.result_data[&#34;content_uri&#34;]

        return self._download_link

    async def download(self, path: str, load_chunk_size: int = 1024) -&gt; None:
        &#34;&#34;&#34;ニコニコ動画の動画をダウンロードします。  
        mp4形式でダウンロードされます。

        Examples
        --------
        ```python
        url = &#34;https://www.nicovideo.jp/watch/sm9720246&#34;
        async with NicoNicoVideoAsync(url) as nico:
            data = await nico.get_info()
            title = data[&#34;video&#34;][&#34;title&#34;]
            await nico.download(title + &#34;.mp4&#34;)
        ```

        Notes
        -----
        もし`async with`構文を使用しないでダウンロードする場合は、ダウンロード前に`connect`を、ダウンロード終了後に`close`を実行してください。  
        動画データの通信に必要なHeartbeatが永遠に動き続けることになります。

        Parameters
        ----------
        path : str
            ダウンロードするニコニコ動画の動画の保存先です。
        load_chunk_size : int, default 1024
            一度にどれほどの量をダウンロードするかです。&#34;&#34;&#34;
        self.print(&#34;Now loading...&#34;)
        url = await self.get_download_link()

        params = (
            (
                &#34;ht2_nicovideo&#34;,
                self.result_data[&#34;content_auth&#34;][&#34;content_auth_info&#34;][&#34;value&#34;]
            ),
        )
        headers = self._headers[1]
        headers[&#34;Content-Type&#34;] = &#34;video/mp4&#34;

        BASE = &#34;Downloading video... :&#34;
        self.print(BASE, &#34;Now loading...&#34;, first=&#34;\r&#34;, end=&#34;&#34;)

        async with self._session.get(url, headers=headers, params=params) as r:
            size, now_size = r.content_length, 0

            self.print(BASE, &#34;Making a null file...&#34;, first=&#34;\r&#34;, end=&#34;&#34;)

            async with async_open(path, &#34;wb&#34;) as f:
                await f.write(b&#34;&#34;)
            async with async_open(path, &#34;ab&#34;) as f:
                async for chunk in r.content.iter_chunked(load_chunk_size):
                    if chunk:
                        now_size += len(chunk)
                        await f.write(chunk)
                        self.print(
                            BASE,
                            f&#34;{int(now_size/size*100)}% ({now_size}/{size})&#34;,
                            first=&#34;\r&#34;, end=&#34;&#34;
                        )

        self.print(&#34;Done.&#34;)

    async def _heartbeat(self, mode = &#34;http_output_download_parameters&#34;) -&gt; None:
        # Heartbeatです。
        self.print(&#34;Starting heartbeat...&#34;)
        if not self._data:
            await self.get_info()

        # セッションに必要なデータを`NicoNicoVideoAsync.get_info`で取得したデータから取得します。
        data = _make_sessiondata(
            self._data[&#34;media&#34;][&#34;delivery&#34;][&#34;movie&#34;], mode=mode
        )
        self.print(&#34;Sending Heartbeat Init Data... :&#34;, data)

        # 一番最初のHeartbeatの通信をします。
        async with self._session.post(
            URLS[&#34;base_heartbeat&#34;] + &#34;?_format=json&#34;,
            headers=self._headers[1], json=data
        ) as r:
            self.result_data = (await r.json(loads=loads))[&#34;data&#34;][&#34;session&#34;]
        session_id = self.result_data[&#34;id&#34;]

        self.print(&#34;Done. session_id. : &#34; + str(session_id))
        self._working_heartbeat.set()

        data, first = {&#34;session&#34;: self.result_data}, True
        get_interval = lambda now: now + data[&#34;session&#34;][&#34;keep_method&#34;][&#34;heartbeat&#34;][&#34;lifetime&#34;] / 1000 - 3
        make_url = lambda session_id: f&#34;{URLS[&#39;base_heartbeat&#39;]}/{session_id}?_format=json&amp;_method=PUT&#34;
        after = get_interval(time())

        while not self._stop:
            now = time()
            # ここで定期的にHeartbeatを送ります。
            if now &gt;= after:
                self.print(&#34;Sending heartbeat...&#34;, data)

                if first:
                    # 最初は普通とは違うやつもリクエストしないといけないのでする。
                    async with self._session.options(
                        make_url(session_id), headers=self._headers[0]
                    ) as r:
                        r.raise_for_status()
                    first = False

                async with self._session.post(
                    make_url(session_id),
                    headers=self._headers[1], json=data
                ) as r:
                    self.result_data = (await r.json(loads=loads))[&#34;data&#34;][&#34;session&#34;]

                self.print(&#34;Done.&#34;)
                data = {&#34;session&#34;: self.result_data}

                after = get_interval(now)
            else:
                await asyncio.sleep(0.05)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="niconico_dl.async_video_manager.NicoNicoVideoAsync.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>NicoNicoVideoAsyncを終了します。<br>
動画のダウンロードに必要な通信をするHeartbeatを止めます。<br>
もし動画のダウンロードが終わったのならこれを実行してください。<br>
<code>async with</code>構文を使用するのならこれを実行する必要はありません。<br>
<code>async with</code>構文の使用例は<code>connect</code>にあります。</p>
<h2 id="warnings">Warnings</h2>
<p>これを使用してもイベントループは閉じません。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;NicoNicoVideoAsyncを終了します。  
    動画のダウンロードに必要な通信をするHeartbeatを止めます。  
    もし動画のダウンロードが終わったのならこれを実行してください。  
    `async with`構文を使用するのならこれを実行する必要はありません。  
    `async with`構文の使用例は`connect`にあります。

    Warnings
    --------
    これを使用してもイベントループは閉じません。&#34;&#34;&#34;
    self._stop = True
    if self.heartbeat_task:
        try:
            self.heartbeat_task.cancel()
        except Exception as e:
            if not isinstance(e, asyncio.CancelledError):
                raise e
    if self.loop.is_closed():
        self._session.detach()
    else:
        self.loop.create_task(self._session.close())</code></pre>
</details>
</dd>
<dt id="niconico_dl.async_video_manager.NicoNicoVideoAsync.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画に接続します。<br>
<code>download</code>を使用するにはこれを実行してからする必要があります。<br>
そしてニコニコ動画との通信が終了したのなら<code>close</code>を実行する必要があります。</p>
<h2 id="notes">Notes</h2>
<p>これと<code>close</code>は以下のように<code>async with</code>構文で省略が可能です。
</p>
<pre><code class="language-python">url = &quot;https://www.nicovideo.jp/watch/sm9664372&quot;
async with niconico_dl.NicoNicoVideoAsync(url) as nico:
    await nico.download(&quot;video.mp4&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self) -&gt; None:
    &#34;&#34;&#34;ニコニコ動画に接続します。  
    `download`を使用するにはこれを実行してからする必要があります。  
    そしてニコニコ動画との通信が終了したのなら`close`を実行する必要があります。

    Notes
    -----
    これと`close`は以下のように`async with`構文で省略が可能です。  
    ```python
    url = &#34;https://www.nicovideo.jp/watch/sm9664372&#34;
    async with niconico_dl.NicoNicoVideoAsync(url) as nico:
        await nico.download(&#34;video.mp4&#34;)
    ```&#34;&#34;&#34;
    self.heartbeat_task = self.loop.create_task(
        self._heartbeat(), name=&#34;niconico_dl.heartbeat&#34;
    )
    await self.wait_until_working_heartbeat()</code></pre>
</details>
</dd>
<dt id="niconico_dl.async_video_manager.NicoNicoVideoAsync.download"><code class="name flex">
<span>async def <span class="ident">download</span></span>(<span>self, path: str, load_chunk_size: int = 1024) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画の動画をダウンロードします。<br>
mp4形式でダウンロードされます。</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">url = &quot;https://www.nicovideo.jp/watch/sm9720246&quot;
async with NicoNicoVideoAsync(url) as nico:
    data = await nico.get_info()
    title = data[&quot;video&quot;][&quot;title&quot;]
    await nico.download(title + &quot;.mp4&quot;)
</code></pre>
<h2 id="notes">Notes</h2>
<p>もし<code>async with</code>構文を使用しないでダウンロードする場合は、ダウンロード前に<code>connect</code>を、ダウンロード終了後に<code>close</code>を実行してください。<br>
動画データの通信に必要なHeartbeatが永遠に動き続けることになります。</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>ダウンロードするニコニコ動画の動画の保存先です。</dd>
<dt><strong><code>load_chunk_size</code></strong> :&ensp;<code>int</code>, default <code>1024</code></dt>
<dd>一度にどれほどの量をダウンロードするかです。</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def download(self, path: str, load_chunk_size: int = 1024) -&gt; None:
    &#34;&#34;&#34;ニコニコ動画の動画をダウンロードします。  
    mp4形式でダウンロードされます。

    Examples
    --------
    ```python
    url = &#34;https://www.nicovideo.jp/watch/sm9720246&#34;
    async with NicoNicoVideoAsync(url) as nico:
        data = await nico.get_info()
        title = data[&#34;video&#34;][&#34;title&#34;]
        await nico.download(title + &#34;.mp4&#34;)
    ```

    Notes
    -----
    もし`async with`構文を使用しないでダウンロードする場合は、ダウンロード前に`connect`を、ダウンロード終了後に`close`を実行してください。  
    動画データの通信に必要なHeartbeatが永遠に動き続けることになります。

    Parameters
    ----------
    path : str
        ダウンロードするニコニコ動画の動画の保存先です。
    load_chunk_size : int, default 1024
        一度にどれほどの量をダウンロードするかです。&#34;&#34;&#34;
    self.print(&#34;Now loading...&#34;)
    url = await self.get_download_link()

    params = (
        (
            &#34;ht2_nicovideo&#34;,
            self.result_data[&#34;content_auth&#34;][&#34;content_auth_info&#34;][&#34;value&#34;]
        ),
    )
    headers = self._headers[1]
    headers[&#34;Content-Type&#34;] = &#34;video/mp4&#34;

    BASE = &#34;Downloading video... :&#34;
    self.print(BASE, &#34;Now loading...&#34;, first=&#34;\r&#34;, end=&#34;&#34;)

    async with self._session.get(url, headers=headers, params=params) as r:
        size, now_size = r.content_length, 0

        self.print(BASE, &#34;Making a null file...&#34;, first=&#34;\r&#34;, end=&#34;&#34;)

        async with async_open(path, &#34;wb&#34;) as f:
            await f.write(b&#34;&#34;)
        async with async_open(path, &#34;ab&#34;) as f:
            async for chunk in r.content.iter_chunked(load_chunk_size):
                if chunk:
                    now_size += len(chunk)
                    await f.write(chunk)
                    self.print(
                        BASE,
                        f&#34;{int(now_size/size*100)}% ({now_size}/{size})&#34;,
                        first=&#34;\r&#34;, end=&#34;&#34;
                    )

    self.print(&#34;Done.&#34;)</code></pre>
</details>
</dd>
<dt id="niconico_dl.async_video_manager.NicoNicoVideoAsync.get_download_link"><code class="name flex">
<span>async def <span class="ident">get_download_link</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画の動画のダウンロードリンクを取得します。<br>
返されるリンクからはmp4の動画をダウンロードできます。</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong> :&ensp;<code>Download link</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="warnings">Warnings</h2>
<p>返されるダウンロードリンクはHeartbeatが動いている間でしか使うことができません。<br>
ですのでHeartbeatを止める<code>close</code>はダウンロードリンクの使用が終わってから実行しましょう。<br>
したがって<code>async with</code>構文を使用して取得したダウンロードリンクはすぐに使えなくなることがあるので注意してください。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_download_link(self) -&gt; str:
    &#34;&#34;&#34;
    ニコニコ動画の動画のダウンロードリンクを取得します。  
    返されるリンクからはmp4の動画をダウンロードできます。

    Returns
    -------
    str : Download link

    Warnings
    --------
    返されるダウンロードリンクはHeartbeatが動いている間でしか使うことができません。  
    ですのでHeartbeatを止める`close`はダウンロードリンクの使用が終わってから実行しましょう。  
    したがって`async with`構文を使用して取得したダウンロードリンクはすぐに使えなくなることがあるので注意してください。
    &#34;&#34;&#34;
    if self._download_link is None:
        # Heartbeatが動いていないなら動かす。
        if not self.is_working_heartbeat():
            await self.connect()
        # Heartbeatが動画のURLを取得するまで待機する。
        await self.wait_until_working_heartbeat()
        self._download_link = self.result_data[&#34;content_uri&#34;]

    return self._download_link</code></pre>
</details>
</dd>
<dt id="niconico_dl.async_video_manager.NicoNicoVideoAsync.get_info"><code class="name flex">
<span>async def <span class="ident">get_info</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>ニコニコ動画のウェブページから動画のデータを取得するコルーチン関数です。</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>取得した動画の情報です。</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NicoNicoAcquisitionFailed</code></dt>
<dd>ニコニコ動画から情報を取得するのに失敗した際に発生します。</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_info(self) -&gt; dict:
    &#34;&#34;&#34;ニコニコ動画のウェブページから動画のデータを取得するコルーチン関数です。

    Returns
    -------
    data : dict
        取得した動画の情報です。

    Raises
    ------
    NicoNicoAcquisitionFailed
        ニコニコ動画から情報を取得するのに失敗した際に発生します。&#34;&#34;&#34;
    self.print(&#34;Getting video data...&#34;)
    if not self._data:
        # もし動画データを取得していないなら動画URLのHTMLから動画データを取得する。
        # Heartbeatの通信にも必要なものでもあります。
        async with self._session.get(self._url, headers=self._headers[2]) as r:
            soup = BeautifulSoup(await r.text(), &#34;html.parser&#34;)
            data = soup.find(&#34;div&#34;, {&#34;id&#34;: &#34;js-initial-watch-data&#34;}).get(&#34;data-api-data&#34;)
            if data:
                self._data = loads(data)
            else:
                raise NicoNicoAcquisitionFailed(&#34;ニコニコ動画から情報を取得するのに失敗しました。&#34;)
    self.print(&#34;Done.&#34;)
    return self._data</code></pre>
</details>
</dd>
<dt id="niconico_dl.async_video_manager.NicoNicoVideoAsync.is_working_heartbeat"><code class="name flex">
<span>def <span class="ident">is_working_heartbeat</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Heartbeatが動いているかの真偽値を返します。</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>is_working</code></strong> :&ensp;<code>bool</code></dt>
<dd>Heartbeatが動いているかどうかの真偽値です。</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_working_heartbeat(self) -&gt; bool:
    &#34;&#34;&#34;Heartbeatが動いているかの真偽値を返します。

    Returns
    -------
    is_working : bool
        Heartbeatが動いているかどうかの真偽値です。&#34;&#34;&#34;
    return self._working_heartbeat.is_set()</code></pre>
</details>
</dd>
<dt id="niconico_dl.async_video_manager.NicoNicoVideoAsync.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, *args, first: str = '', **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>niconico_dl用に用意したログ出力用の<code>print</code>です。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, *args, first: str = &#34;&#34;, **kwargs) -&gt; None:
    &#34;&#34;&#34;niconico_dl用に用意したログ出力用の`print`です。&#34;&#34;&#34;
    if self._log:
        print(
            f&#34;{first}[niconico_dl_async]&#34;,
            *args, **kwargs
        )</code></pre>
</details>
</dd>
<dt id="niconico_dl.async_video_manager.NicoNicoVideoAsync.wait_until_working_heartbeat"><code class="name flex">
<span>async def <span class="ident">wait_until_working_heartbeat</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Heartbeatが動き出すまで待機します。</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_until_working_heartbeat(self) -&gt; None:
    &#34;&#34;&#34;Heartbeatが動き出すまで待機します。&#34;&#34;&#34;
    await self._working_heartbeat.wait()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="niconico_dl" href="index.html">niconico_dl</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="niconico_dl.async_video_manager.NicoNicoVideoAsync" href="#niconico_dl.async_video_manager.NicoNicoVideoAsync">NicoNicoVideoAsync</a></code></h4>
<ul class="">
<li><code><a title="niconico_dl.async_video_manager.NicoNicoVideoAsync.close" href="#niconico_dl.async_video_manager.NicoNicoVideoAsync.close">close</a></code></li>
<li><code><a title="niconico_dl.async_video_manager.NicoNicoVideoAsync.connect" href="#niconico_dl.async_video_manager.NicoNicoVideoAsync.connect">connect</a></code></li>
<li><code><a title="niconico_dl.async_video_manager.NicoNicoVideoAsync.download" href="#niconico_dl.async_video_manager.NicoNicoVideoAsync.download">download</a></code></li>
<li><code><a title="niconico_dl.async_video_manager.NicoNicoVideoAsync.get_download_link" href="#niconico_dl.async_video_manager.NicoNicoVideoAsync.get_download_link">get_download_link</a></code></li>
<li><code><a title="niconico_dl.async_video_manager.NicoNicoVideoAsync.get_info" href="#niconico_dl.async_video_manager.NicoNicoVideoAsync.get_info">get_info</a></code></li>
<li><code><a title="niconico_dl.async_video_manager.NicoNicoVideoAsync.is_working_heartbeat" href="#niconico_dl.async_video_manager.NicoNicoVideoAsync.is_working_heartbeat">is_working_heartbeat</a></code></li>
<li><code><a title="niconico_dl.async_video_manager.NicoNicoVideoAsync.print" href="#niconico_dl.async_video_manager.NicoNicoVideoAsync.print">print</a></code></li>
<li><code><a title="niconico_dl.async_video_manager.NicoNicoVideoAsync.wait_until_working_heartbeat" href="#niconico_dl.async_video_manager.NicoNicoVideoAsync.wait_until_working_heartbeat">wait_until_working_heartbeat</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>